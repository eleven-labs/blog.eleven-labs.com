---
layout: post
title: RxSwift pour les nuls: Partie 1
excerpt: Dans cet article, on abordera les Observables qui sont le coeur du RxSwift ainsi que les Subjects
authors:
    - Safia11
lang: LANGUE (fr/en)
permalink: /fr/RxSwiftpourlesnuls:Partie1/
---
Avant d’entrer dans le vif du sujet qui est RxSwift, voyons un peu c’est quoi la programmation réactive. 

##Programmation réactive

La programmation réactive parle uniquement de flux et de données. 

Un flux créé des données à différents moments dans le temps. Un observateur sera quand à lui notifié quand ces données seront récupérées, afin qu'il puisse réaliser une action spécifique avec celles-ci. 


##RxSwift

Tout d’abord, RxSwift est une librairie qui va permettre d’écrire un code asynchrone d’une manière plus concise, compacte et maintenable. Il est basé sur les observables qui eux, une séquence de data à qui on peut réagir comme par exemple dans le cas où un utilisateur appuie sur un bouton. 

Elle est basée sur 2 pattern qui sont: Observer et Iterator.

Mais que signifie le préfixe Rx? Rx veut dire “ReactiveX”; On créera des séquences observables et on va les parcourir d’une manière itérative. 

Pour pouvoir utiliser RxSwift, il faut l’installer en utilisant la gestion des dépendances (CocoaPods || Carthage || Swift Package Manager) 

Dans cette première partie,  je vais parler des Observables qui sont le coeur du RxSwift ainsi que les Subjects. 


##Les Observables

Un Observable ? C’est quoi ?  

Le framework RxSwift est basé sur les observables. En RxSwift on les appelle “Observable sequence” alors que pour les autre plateformes, c’est bien “Observable streams”. 

Les observables est une séquence d'éléments qui  peuvent émettre des valeurs. Ses valeurs peuvent être des Int, String ou bien un autre Object.

Découvrons comment les implémenter en utilisant les Operators: 

```Swift
import RxSwift

let observable1 = Observable.just(1)

let observable2 = Observable.of(1,2,3)

let observable3 = Observable.of([1,2,3])

let observable4 = Observable.from([1,2,3,4,5])
```

.just( ): Ici on a créé un observable qu’on a nommé “observable1” en utilisant la classe Observable. La classe Observable contient plusieurs méthodes qui permettent de créer un observable. 

Pour cet exemple on a utilisé la méthode just qui retourne une séquence qui contient un et un seul élément qui est dans notre cas 1.

of( ): “of” est une fonction qui permet de créer une séquence d’éléments différents. 

Si on se souscrit à ses éléments, on aura les valeurs 1, 2 et 3. Le type de l’observable dans ce cas est Observable&lt;Int&gt;.

of(): on a créé un autre observable, sauf que son type est Observable&lt;[Int]&gt;.

from( ): Ici on a utilisé “from” pour créer un Observable qui prend un array d’éléments comme paramètre et la convertit. Notez bien que le type de l’Observable est Observable&lt;Int&gt; 


Là on vient de créer nos observables qui émettent les évents c’est quoi la prochaine étape ? 

La prochaine étape est automatiquement recevoir ce qui était émis, les observer. En un autre terme: “To subscribe” 


##Subscribing

Quand on se souscrit à un observable, on reçoit les événements émis par l’observable. 

L’événement a trois états. En fait c’est une énumération qui a trois “case”:

- next  
- error 
- completed 
  
On se souscrit en utilisant “subscribe” qui prend une closure en tant que paramètre. 

```Swift
import RxSwift

let observable = Observable.from([1,2,3,4,5])

observable.subscribe { event in
    print(event)
}

/*

Résultat Console:
next(1)
next(2
next(3)
next(4)
next(5)
completed

 */
```
Mais comment récupérer les valeurs 1, 2, 3, 4 et 5? C’est simple en utilisant .element:

```Swift
import RxSwift  

let observable = Observable.from([1,2,3,4,5])

observable.subscribe { event in

   if let element = event.element {
        print(element)
    }
}

/*
Résultat Console: 
1
2
3
4
5

*/
```
Il existe une autre méthode pour pouvoir accéder aux éléments d’un observateur sans avoir à unwrapper; en utilisant subscribe(onNext):

```Swift
import RxSwift

let observable = Observable.from([1,2,3,4,5])

observable.subscribe(onNext: { element in
    print(element)
})

/*

Résultat Console:
1
2
3
4
5

*/

```
Notez que le completed event n’est pas affiché. 

##Dispose bag:

Quand on crée une subscription, elle nous retourne un subscriber et ce dernier sera toujours là pour observer cette séquence. Du coup il faut être sûr de disposer ces subscribers. Si on les dispose pas on aura une fuite de mémoire.

Il existe 2 méthodes pour disposer, en utilisant dispose() ou bien disposeBag: 

Passons à la pratique:

En utilisant Dispose():

```Swift
import RxSwift

let observable = Observable.from([1,2,3,4,5])

let subscription = observable.subscribe(onNext: { element in
    print(element)
})

subscription.dispose()
```
En utilisant DisposeBag():

```Swift
import RxSwift

let disposeBag =  DisposeBag()

Observable.of("A", "B", "C").subscribe {
    print($0)
}.disposed(by: disposeBag)
```

##Subjects

Subject est en même temps un Observable ainsi qu’un Observer. Yes, 2 in 1.

En RxSwift, il existe plusieurs types de Subject. Dans cet article je parlerai que de trois qui sont:  Publish Subject, Behavior Subject, Replay Subjects.

### Publish Subject

Publish Subject émet les nouveaux événement seulement aux nouveaux souscrit. Si d’autres événements ont été ajoutés au subject avant la souscription d’un subscriber, il ne vas pas les recevoir.   

```Swift
import RxSwift

let subject = PublishSubject<String>() // (1)

subject.onNext("Something1")

subject.subscribe { event in // (2)
    print(event)
}

subject.onNext("Something2")
subject.onNext("Something3")
subject.dispose() //(3)
subject.onNext("Something4")

/*
 Résultat Console:
 
 next(Something2)
 next(Something3)

 */
```
(1): Ici le subject est une séquence vide. 
  
(2): Si on exécute, on ne verra pas la souscription. La raison est qu’on a créé la subscription après d’avoir crée l’événement (Ils n'y a pas des subscribers ). Mais si on a créé l’événement après la souscription, on peut du coup les récupérer.

On peut penser à ça comme si on s’est abonné chez quelqu’un sur Instagram par exemple et du coup on peut pas voir les nouveautés (les events) si on s’est pas abonné (souscrit).

(3) : toutes les souscriptions qui arrivent après le dispose seront négligés, même l’événement completed est ignoré. 


### Behavior Subject

Parfois on voudrait que le subscriber reçoit l’événement le plus récent  même s’il se souscrit après.  Le Behavior Subject va renvoyer le dernier événement ou bien le valeur initial dans le cas où il n’y a pas de nouveaux événements récents avant sa souscription ainsi que les événements après la souscription. Notez que le Behavior Subject doit absolument être initialisé par une valeur qui sera considérée le premier next event. 

```Swift
import RxSwift

let disposeBag = DisposeBag()

let subject = BehaviorSubject(value: "First")

subject.subscribe { event in
    print(event)
}.disposed(by: disposeBag)


subject.onNext("Second")
subject.onNext("Third")
subject.onNext("Fourth")

/*
 Résultat Console:
 
 next(First)
 next(Second)
 next(Third)
 next(Fourth)
 
 */

```

Behavior Subject est un peu près similaire à Publish Subjects. La seule différence est pour qu’il puisse être initialisé, on doit au moins lui passer une valeur initiale.  

```Swift
import RxSwift

let disposeBag = DisposeBag()

let subject = BehaviorSubject(value: "First")
subject.onNext("Before Subscribing")
subject.onNext("Before Subscribing 2")

subject.subscribe { event in
    print(event)
}.disposed(by: disposeBag)

subject.onNext("Second")
subject.onNext("Fourth")
subject.onNext("Fifth")

/*
 Résultat Console:
 
 next(Before Subscribing 2)
 next(Second)
 next(Fourth)
 next(Fifth)
*/
```

Notez que dans le premier exemple, le subscriber a été initialisé avec la valeur “First” et il n’y avait pas d’autres événements avant la souscription, donc c’est la seule valeur prise en compte avant la souscription. Or dans ce deuxième exemple, deux évent ont eu lieu avant la souscription et le seul event pris en compte est le plus récent qui est “Before Subscribing 2” 

### Replay Subject

On vient de voir 2 types de subjects, le Publish Subject ainsi que le Behavior Subject. Regardons un peu ce que fait le Replay Subject.

Replay Subject émet un nombre spécifique d’événement avant la souscription. Ce nombre est la valeur du buffer spécifié lors de la création du buffer.  

```Swift
import RxSwift

let disposeBag = DisposeBag()

let subject = ReplaySubject<String>.create(bufferSize: 2)

subject.onNext("Premier")
subject.onNext("Deuxième")
subject.onNext("Troisième")

subject.subscribe { event in
    print(event)
}.disposed(by: disposeBag)

subject.onNext("Quatrième")
subject.onNext("Cinquième")
subject.onNext("Sixième")

/*
 Résultat Console:
 
 next(Deuxième)
 next(Troisième)
 next(Quatrième)
 next(Cinquième)
 next(Sixième)
 
 */ 

```

Replay subjects fait passer les derniers événement on se basant sur la longueur du buffer précisé lors de la création du subject.

## Conclusion

C’est tout pour cette première partie sur RxSwift. J’espère que c’était une première découverte de RxSwift et spécialement ce que sont les Observables, les Subscribers ainsi que les Subjects. Une deuxième partie arrivera bientôt où je traiterai les “Filtering Operators”, “Transforming Operators” ainsi que les “Combing Operators”. Stay tuned !! 

Pour ceux qui veulent approfondir leurs connaissances, je ne peux que vous conseillez le livre de Raywenderlish que vous trouverez [Ici]: (https://store.raywenderlich.com/products/rxswift)

 
