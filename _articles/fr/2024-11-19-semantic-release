---
contentType: article
lang: fr
date: '2024-11-19'
slug: semantic-release
title: Automatiser la création de la version d'une application avec semantic-release
excerpt: Automatiser la création de la version d'une application avec semantic-release
categories:
  - devops
authors:
  - tthuon
keywords: []
---

Votre est prête à être livrée. Pour cela, vous avez besoin de marquer votre application avec un numéro de version. Une convention permet de faciliter le suivi de version : [Gestion sémantique de version](https://semver.org/lang/fr/).

La livraison de la version 1.0.0 s'est déroulé avec succès. Maintenant, vous avez besoin d'ajouter de nouvelles fonctionnalité. Il faudra donc incrémenter le numéro de version.

Deux options possibles : 
- marquer la prochaine version manuellement
- automatiser ce processus en suivant une convention

Automatisons ce processus.

## Convention de nommage des commits

Afin d'automatiser le processus de marquage des versions, nous allons nous référer à l'historique des commits du dépôt Git. Une nouvelle version d'un logiciel peut se définir par un ensemble de commit entre la précédente version et la tête de la branche principale.

Nos commits doivent respecter une convention. Pour cela, nous allons utiliser [Commits Conventionnels](https://www.conventionalcommits.org/fr/v1.0.0/).

Pour simplifier, un commit commençant par 
- "feat: " va incrémenter le numéro de version mineur
- "fix: " va incrémenter le numéro de version de correctif

Une fois que nos commits respectent la nomenclature défini par Commits Conventionnels, nous pouvons utiliser un outil pour effectuer le différentiel de version : [semantic-release](https://github.com/semantic-release/semantic-release).

## semantic-release

semantic-release va automatiser ce processus de marquage d'une version d'un logiciel.

Cela nécessite quelques configurations.

Tout d'abord, il faut créer un fichier `.releaserc.yml` avec le contenu suivant : 

```yaml
plugins:
  -
    - "@semantic-release/commit-analyzer"
    - preset: "conventionalcommits"
  -
    - "@semantic-release/release-notes-generator"
    - preset: "conventionalcommits"
  - "@semantic-release/gitlab"
branches:
  - "main"
```

Cette configuration ajoute deux modules pour utiliser les commits conventionnels, et un troisième pour s'intégrer avec Gitlab.

Enfin, la branche de référence en `main` dans notre cas.

Dans le fichier `.gitlab-ci.yml`, ajoutons une tâche pour générer le prochain numéro de version.

```yaml
release:
  image: dockerhub.ftven.net/node:lts
  stage: release
  variables:
    GITLAB_TOKEN: ${RELEASE_TOKEN}
  before_script:
    - npm install semantic-release@"^23.0.8" @semantic-release/gitlab@"^13.0.4" conventional-changelog-conventionalcommits@"^7.0.2"
  script:
    - npx semantic-release
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
```

