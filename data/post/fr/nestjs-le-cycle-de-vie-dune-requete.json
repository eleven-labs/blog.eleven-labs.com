{"date":"2022-03-29T00:00:00.000Z","title":"NestJS : le cycle de vie d'une requ√™te","excerpt":"Cet article vous expliquera pr√©cisemment chaque √©tape par laquelle passent une requ√™te et une r√©ponse dans une application NestJS.","readingTime":"12mn","authors":["ajacquemin"],"categories":["javascript"],"content":"\nBienvenue dans cet article ayant pour but de faire un tour d'horizon du cycle de vie d'une requ√™te puis d'une r√©ponse dans un environnement NestJS !\n\n<br />\n\n<div style=\"text-align: center;\">\n    <img src=\"/imgs/posts/2022-03-04-nestjs-le-cycle-de-vie-dune-requete/nest-logo.png\" width=\"300px\" alt=\"NestJS logo\" style=\"display: block; margin: auto;\"/>\n    <i>NestJS Framework</i>\n</div>\n\n<br />\n\nLe but ici sera de donner une repr√©sentation pr√©cise de chaque √©tape que peut rencontrer une requ√™te, dans l'ordre, et avec des exemples. Une fois lu une premi√®re fois, gardez cet article dans un coin, √† la mani√®re d'un **pense-b√™te**. \nAinsi, en cas de confusion ou d'esprit embrum√© le lendemain d'un jeudi soir un peu arros√©, il sera votre meilleur alli√© pour que votre gueule de bois passe inaper√ßue.\n\nVoil√† d'ailleurs un **sommaire** pour retrouver rapidement la partie qui vous int√©resse :\n\n- [Pr√©sentation globale du cycle de vie requ√™te / r√©ponse](#cycle-de-vie--vue-globale)\n- [Les niveaux de d√©claration](#niveaux-de-d√©claration)\n- [Pr√©sentation des Middlewares](#les-middlewares)\n- [Pr√©sentation des Guards](#les-guards)\n- [Pr√©sentation des Interceptors](#les-interceptors)\n- [Pr√©sentation des Pipes](#les-pipes)\n- [Pr√©sentation du Controller](#le-controller)\n- [Pr√©sentation des Exception Filters](#les-exception-filters)\n- [Conclusion](#conclusion)\n\n<div  class=\"admonition note\"  markdown=\"1\"><p  class=\"admonition-title\">Note</p>\n\nVous pouvez √™tre totalement d√©butant en NestJS et quand m√™me lire cet article. C'est peut-√™tre m√™me recommand√©.\n</div>\n\n## Cycle de vie : vue globale\nRien de tel qu'un sch√©ma que je vous ai concoct√© pour entrer dans le vif du sujet. Je vous laisse vous en impr√©gner.\n\n![](/imgs/posts/2022-03-04-nestjs-le-cycle-de-vie-dune-requete/nest-lifecycle-schema.png)\n\n<div  class=\"admonition note\"  markdown=\"1\"><p  class=\"admonition-title\">Note</p>\n\nIl s'agit d'un parcours plut√¥t exhaustif d'une requ√™te, mais la seule √©tape r√©ellement essentielle ici est le **Controller**. Il a pour r√¥le de recevoir votre requ√™te, la traiter, et renvoyer une r√©ponse. Tout le reste est facultatif.\n</div>\n\nComme vous pouvez le constater, une requ√™te, avant d'arriver au **Controller**, peut passer par 4 premi√®res couches qui sont dans l'ordre : **Middleware** -> **Guard** -> **Interceptor** -> **Pipe**.\nPuis, libre √† votre **Controller** d'appeler tout **Service** (o√π par convention repose votre logique m√©tier) ou **Repository** (pour les appels √† la base de donn√©es) pour traiter la requ√™te.\nEnfin, le **Controller** renverra une r√©ponse qui, comme vous le constatez, peut √† nouveau passer par un **Interceptor**, puis par les **Exception Filters**.\nNous allons dans cet article expliquer √† quoi correspond chacune de ces √©tapes.\n\nChacune de ces couches peut √™tre d√©clar√©e sur un ou plusieurs niveaux, rendez-vous dans la section suivante pour les d√©couvrir.\n\n## Niveaux de d√©claration\n\nAvant de d√©finir plus en d√©tail chacune des couches vues pr√©c√©demment, il me semblait important de parler des *niveaux de d√©claration*.\nEn r√©alit√©, chacune de ces √©tapes que traverse la requ√™te peut se diviser en 1 ou plusieurs sous-√©tapes. Pas de panique, rien de tr√®s compliqu√© ici, voyons par l'exemple.\n\nTout d'abord, il existe 5 niveaux de d√©clarations :\n\n- D√©claration **globale**\n- D√©claration au niveau **Module**\n- D√©claration au niveau **Controller**\n- D√©claration au niveau **Route**\n- D√©claration au niveau **param√®tre de route**\n\n<div  class=\"admonition note\"  markdown=\"1\"><p  class=\"admonition-title\">Note</p>\n\nPar exemple, un Interceptor peut √™tre d√©clar√© √† 3 niveaux :\n\n- Globalement\n- Au niveau d'un controller\n- Au niveau d'une route\n\nUn Interceptor global intercepte toutes les requ√™tes, tandis qu'un Interceptor plac√© au niveau d'un Controller / d'une route intercepte seulement les requ√™tes qui passent par ce Controller / cette route.\n</div>\n\nAinsi, sachez que lors d‚Äôune requ√™te, au sein de chaque couche, l‚Äôordre de passage est toujours :\n\nNiveau **global** => Niveau **module** => Niveau **controller** => Niveau **route** => Niveau **param√®tre de route**.\n\nReprenons donc une partie de notre sch√©ma vu plus haut, mais mis √† jour. Cela donnerait  :\n\n![](/imgs/posts/2022-03-04-nestjs-le-cycle-de-vie-dune-requete/updated-lifecycle-schema.png)\n\nCi-dessous √† titre indicatif, vous trouverez des exemples de d√©claration pour chaque niveau. Rendez-vous dans les prochaines sections pour les pr√©sentations plus pouss√©es de toutes nos couches (Middlewares, Interceptors...).\n\n### D√©claration globale\n\nExemple avec un Guard :\n\n```javascript\n// app.module.ts\n\n// ...\n  providers: [\n    {\n      provide: APP_GUARD,\n      useClass: UserGuard,\n    },\n  ],\n// ...\n```\n\n=> Ce Guard est appliqu√© globalement = √† toute l'application (quel que soit le module o√π il est d√©clar√©).\n\n\n### D√©claration niveau module\n\nExemple avec un Middleware :\n\n```javascript\n// app.module.ts\n\n// ...\n\n// Style de d√©claration sp√©cifique aux Middlewares\nconfigure(consumer: MiddlewareConsumer): void {\n    consumer\n      .apply(LoggerMiddleware)\n      .forRoutes('*');\n}\n```\n\n=> Ce Middleware est d√©clar√© au niveau d'un module, il est donc appel√© apr√®s tout √©ventuel Middleware d√©clar√© globalement. Cela √©tant dit, un Middleware d√©clar√© comme ci-dessus s'applique sur toutes les routes de l'application gr√¢ce au wildcard `*`.\n\n\n### D√©claration niveau Controller\n\nExemple avec un Interceptor :\n\n```javascript\n// some-controller.ts\n\n@UseInterceptors(LoggingInterceptor)\nexport class SomeController {}\n```\n\n=> Cet Interceptor sera appliqu√© √† toutes les routes de ce Controller.\n\n### D√©claration niveau route\n\nExemple avec un Guard :\n\n```javascript\n// some-controller.ts\n\n// ...\n@UseGuards(new RolesGuard())\n@Get()\nasync someRoute(): any {\n  // ...\n}\n// ...\n```\n\n### D√©claration niveau param√®tres de route\n\nExemple avec un Pipe :\n\n```javascript\n// some-controller.ts\n\n// ...\n@Get(':id')\nasync someRoute(@Param('id', ParseIntPipe) id: number): any {\n  // ...\n}\n// ...\n```\n\n<div  class=\"admonition note\"  markdown=\"1\"><p  class=\"admonition-title\">Note</p>\n\nL'annotation `@Param` permet de s√©lectionner un param√®tre de l'URL, ici `:id`.\n</div>\n\nPassons maintenant √† l'explication de chacun de ces concepts que nous survolons depuis le d√©but. Pour chacun, en d√©but de section, je mettrai une petite note indiquant √† quel(s) niveau(x) il est d√©clarable.\n\n## Les Middlewares\n\n<div  class=\"admonition info\"  markdown=\"1\"><p  class=\"admonition-title\">Niveaux de d√©claration possibles</p>\n\n- Global\n- Module\n</div>\n\nVous √™tes peut-√™tre d√©j√† familiers du concept si vous avez d√©j√† fait du d√©veloppement en NodeJS.\nLe Middleware est toujours appel√© avant le Controller et il a acc√®s √† la requ√™te ainsi qu'√† la r√©ponse (par cons√©quent pas encore peupl√©e par le retour du Controller).\n\nVoil√† un exemple de Middleware en Nest :\n\n```javascript\n@Injectable()  \nexport class CurrentUserMiddleware implements NestMiddleware {  \n  constructor(private userService: UserService) {}  \n  \n  async use(req: Request, _: Response, next: NextFunction): Promise<void> {  \n    const { userId } = req.session;  \n  \n    if (userId) {  \n      const user = await this.userService.getUserById(userId);  \n  \n      if (user) {  \n        req.currentUser = user;  \n      }  \n    }  \n  \n    next();  \n  }  \n}\n```\n\nDans cet exemple, nous r√©cup√©rons un potentiel objet `session` dans la requ√™te, puis nous peuplons la requ√™te avec un *user* complet, √† l'aide de l'id trouv√© dans la `session`. Enfin, nous n'oublions pas d'appeler `next()` pour continuer l'ex√©cution.\n\n<div  class=\"admonition note\"  markdown=\"1\"><p  class=\"admonition-title\">Note</p>\n\nUn Middleware doit impl√©menter la fonction `use()`.\n\nDe plus, il doit se terminer par un appel √† la fonction `next()` pour pouvoir passer √† la suite des √©tapes d'ex√©cution. Sans le `next()`, la requ√™te est suspendue.\n</div>\n\n## Les Guards\n\n<div  class=\"admonition info\"  markdown=\"1\"><p  class=\"admonition-title\">Niveaux de d√©claration possibles</p>\n\n- Global\n- Controller\n- Route\n</div>\n\nLe Guard est une classe dont la mission est le plus souvent l'autorisation. Un Guard a acc√®s √† tout le **contexte d'ex√©cution** d'une requ√™te. Il a donc la connaissance de ce qui sera ex√©cut√© apr√®s lui (quel Controller, quelle fonction, quelle route...). \n\nIl peut par exemple v√©rifier quels sont les r√¥les n√©cessaires pour acc√©der au Controller qui sera appel√© dans la foul√©e, et avorter la requ√™te si elle ne contient pas le r√¥le requis.\n\nPrenons l'exemple d'un Guard appel√© √† la suite du Middleware que nous avons √©crit plus haut. Voil√† ce qu'on pourrait faire :\n\n```javascript\n@Injectable()\nexport class AdminRoleGuard implements CanActivate {\n  canActivate(context: ExecutionContext): boolean {\n    const request = context.switchToHttp().getRequest();\n\n    return request.currentUser.role === UserRole.ADMIN;\n  }\n}\n```\n\nIci, on v√©rifie si l'utilisateur stock√© plus t√¥t dans la requ√™te a le r√¥le **ADMIN**. \n\n<div  class=\"admonition note\"  markdown=\"1\"><p  class=\"admonition-title\">Note</p>\n\nUn Guard doit impl√©menter la fonction  `canActivate()`, qui retourne un bool√©en, de mani√®re synchrone ou dans une Promesse ou un Observable. \n</div>\n\n## Les Interceptors\n\n<div  class=\"admonition info\"  markdown=\"1\"><p  class=\"admonition-title\">Niveaux de d√©claration possibles</p>\n\n- Global\n- Controller\n- Route\n</div>\n\nOn compare souvent les Interceptors avec les Middlewares. Leurs diff√©rences sont nombreuses mais en voici quelques unes :\n\n- Un Interceptor est appel√© √† la fois lors de la **requ√™te**, mais aussi lors de la **r√©ponse**.\n- Comme le Guard, l'Interceptor a acc√®s au **contexte d'ex√©cution** (qui contient la requ√™te), contrairement au Middleware qui a acc√®s √† la requ√™te, mais pas au contexte d'ex√©cution.\n- Comme vous le savez maintenant, l'Interceptor est appel√© **apr√®s** le Guard. Le Middleware est lui appel√© **avant**.\n\nSouvent, les Interceptors sont utilis√©s pour *serializer* les r√©ponses renvoy√©es par le Controller, par exemple :\n\n```javascript\nclass UserSerializerInterceptor implements NestInterceptor {\n  intercept(_: ExecutionContext, next: CallHandler): Observable<unknown> {\n    return next.handle().pipe(\n      map((user) =>\n        plainToInstance(UserDto, user),\n      ),\n    );\n  }\n}\n```\n\nL'Interceptor doit impl√©menter la fonction `intercept()` qui prend 2 arguments, repr√©sentant respectivement :\n\n- Un **ExecutionContext**, contenant notamment la requ√™te.\n- un **CallHandler**, qui donne acc√®s √† la r√©ponse.\n\n<div  class=\"admonition note\"  markdown=\"1\"><p  class=\"admonition-title\">Comment √ßa marche ?</p>\n\nL'interface `CallHandler` impl√©mente la m√©thode `handle()`, qui retourne un Observable. C'est ainsi que l'Interceptor reste √† l'√©coute de la r√©ponse. R√©ponse que vous pouvez ensuite manipuler comme n'importe quel Observable classique. Ici on utilise la fonction `plainToInstance()` de la librairie *class-transformer*, qui serialize un objet Javascript selon une classe donn√©e; ici un hypoth√©tique UserDto.\n</div>\n\n## Les Pipes\n\n<div  class=\"admonition info\"  markdown=\"1\"><p  class=\"admonition-title\">Niveaux de d√©claration possibles</p>\n\n- Global\n- Controller\n- Route\n- Param√®tre de route\n</div>\n\nLes Pipes ont 2 cas d'usage : la **validation** des donn√©es, et la **transformation**.\n\nVoici un exemple tir√© cette fois de la [documentation de NestJS](https://docs.nestjs.com/pipes) :\n\n```javascript\n@Injectable()\nexport class ParseIntPipe implements PipeTransform<string, number> {\n  transform(value: string, metadata: ArgumentMetadata): number {\n    const val = parseInt(value, 10);\n    \n    if (isNaN(val)) {\n      throw new BadRequestException('Validation failed');\n    }\n    \n    return val;\n  }\n}\n```\n\nIci on r√©cup√®re une cha√Æne de caract√®res que nous tentons de **transformer** en nombre. Si la cha√Æne de caract√®res contient autre chose que des chiffres, on fait √©chouer la **validation**.\n\nVoil√† l'utilisation de ce Pipe, associ√© √† un param√®tre d'une route :\n\n```javascript\n@Get(':id')\nasync findOne(@Param('id', ParseIntPipe) id: number): Cat {\n  return this.catsService.findOne(id);\n}\n```\n\n## Le Controller\n\nEt nous voil√† au coeur du traitement de notre requ√™te. Nous ne perdrons pas de temps ici √† expliquer tout ce qu'est capable de faire un Controller en NestJS car ce n'est pas l'objet de cet article.\n\nMais voil√† un exemple d'un Controller appel√© dans la lign√©e de nos exemples pr√©c√©dents :\n\n```javascript\n@Get('admin/some-secret-route')\n@UseGuards(AdminRoleGuard)\nasync findOne(): User {\n  return this.adminService.somePrivateData();\n}\n```\n\n<div  class=\"admonition important\"  markdown=\"1\"><p  class=\"admonition-title\">Important</p>\n\nAvec l'annotation `@UseGuards()`, on utilise √©galement un Guard (celui que nous avons √©crit plus haut) au niveau de la route. Ainsi, nous sommes s√ªrs que l'utilisateur qui appelle cette route est bien un administrateur.\n</div>\n\nNous n'irons pas plus loin dans le traitement de la **requ√™te**, sachez juste qu'habituellement un Controller appelle un service, √† l'int√©rieur duquel se trouve la logique m√©tier, et les appels √©ventuels aux Repositories, o√π r√©sident la connexion √† la base de donn√©es.\n\n> Votre mantra : quoiqu'il arrive, votre Controller doit r√©cup√©rer une requ√™te, et retourner une r√©ponse.\n\n## Les Exception filters\n\n<div  class=\"admonition info\"  markdown=\"1\"><p  class=\"admonition-title\">Niveaux de d√©claration possibles</p>\n\n- Global\n- Controller\n- Route\n</div>\n\n\nLes Exception Filters permettent de `catch` les exceptions que vous d√©clenchez dans votre code, pour les transformer en messages d'erreur lisibles dans la r√©ponse du serveur.\nNestJS fournit par d√©faut un Exception Filter **global** qui r√©cup√®re toutes les Exceptions de type `HttpException`. \n\nC'est-√†-dire que vous pouvez par exemple faire ceci dans un Controller :\n\n```javascript\n@Get('some-admin-route')\nasync adminRoute(): any {\n  throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);\n}\n```\n\nEt par d√©faut, NestJS g√©n√®rera une r√©ponse JSON reprenant le code d'erreur `403` d'une exception Forbidden.\n\nLa plupart du temps vous n'avez donc par √† cr√©er d'Exception Filter custom, vu qu'une bonne pratique est de renvoyer des erreurs HTTP pour des applications REST ou encore GraphQL ; et donc Nest s'en occupera pour vous.\n\nMais voici tout de m√™me un court exemple de ce √† quoi ressemble la d√©finition d'un Exception Filter :\n\n```javascript\n@Catch(HttpException)\nexport class CustomExceptionFilter implements ExceptionFilter {\n  catch(exception: HttpException, host: ArgumentsHost) {\n    // handle exception\n  }\n}\n```\n\nL'annotation `@Catch()` permet de sp√©cifier quelle exception vous souhaitez \"√©couter\".\n\nLe deuxi√®me argument de la fonction `catch()` est un objet de type `ArgumentHost`. Cet objet contient tout le contexte d'ex√©cution ; vous pouvez y retrouver notamment la **requ√™te** et la **r√©ponse**. C'est surtout cette derni√®re qui vous int√©resse, pour par exemple y ajouter un message relatif √† l'exception r√©cup√©r√©e.\n\n## Conclusion\n\nVous savez √† pr√©sent √† peu pr√®s tout sur le cycle de vie d'une requ√™te en NestJS. Le but √©tait surtout de donner une meilleure vue d'ensemble de ces diff√©rentes √©tapes, de leur **ordre** d'ex√©cution, et de leur utilit√©. Mais si vous voulez en savoir plus sur **comment** les impl√©menter, √† diff√©rents niveaux (module, controller, route...), n'h√©sitez pas √† vous r√©f√©rer √† la [documentation officielle de NestJS](https://docs.nestjs.com).\n\n√Ä tr√®s bient√¥t üëã\n"}