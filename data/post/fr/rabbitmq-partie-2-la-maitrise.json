{"date":"2018-04-11T00:00:00.000Z","title":"RabbitMQ des bases Ã  la maÃ®trise (Partie 2)","excerpt":"Les policies, le retry (dead letter, poison message)... en avant pour l'utilisation avancÃ©e de RabbitMQ.","readingTime":"6mn","authors":["amoutte"],"categories":[],"content":"\nLes policies, le retry (dead letter, poison message)... en avant pour l'utilisation avancÃ©e de RabbitMQ.\n\n## Introduction\n\nAprÃ¨s avoir vu les bases dans [RabbitMQ : Les bases (Partie 1)](/fr/rabbitmq-partie-1-les-bases/),\nnous allons pousser un peu plus loin l'utilisation de RabbitMQ.\n\n## Plugins\n\n> ğŸ¥• Les plugins sont comme des engrais pour votre champ de carottes.\n\nJe vous invite Ã  consulter la page des [plugins](https://www.rabbitmq.com/plugins.html) ainsi que le [Github](https://github.com/rabbitmq)\nafin de voir les plugins officiels disponibles.\n\nD'autre part je vous conseille fortement d'activer au minimum les plugins suivants :\n\n* `rabbitmq_management` ce plugin ajoute une interface web trÃ¨s pratique pour configurer RabbitMQ.\n* `rabbitmq_tracing` ce plugin (dans l'onglet Admin > Tracing) vous permet de tracer (debug) les messages.\n\n## Authentification / Autorisation\n\nDans tout systÃ¨me d'informations, l'utilisation de permissions, par utilisateur/groupe, est une notion trÃ¨s importante.\nElle permet d'organiser et maÃ®triser l'utilisation et l'accÃ¨s au service.\n\nRabbitMQ embarque un systÃ¨me interne d'authentification/autorisation mais une fois de plus il existe diffÃ©rents [plugins d'auth](https://github.com/rabbitmq?q=rabbitmq-auth).\n\n> â„¹ï¸ Avec le plugin [rabbitmq-auth-backend-http](https://github.com/rabbitmq/rabbitmq-auth-backend-http) vous pouvez mÃªme\n> dÃ©lÃ©guer cette partie Ã  une API HTTP (Les utilisateurs de votre plateforme sont connectÃ©s Ã  RabbitMQ ! ğŸ˜œ).\n> Voici une [implÃ©mentation en PHP](https://github.com/symftony/rabbitmq-auth-backend-http-php) qui utilise le composant security de Symfony.\n\nVous avez mÃªme la possibilitÃ© de configurer plusieurs systÃ¨mes d'auth en cascade.\n\n```\nauth_backends.my_auth_1 = internal\nauth_backends.my_auth_2 = http\n...\n```\n\n> Ici les valeurs `my_auth_1` et `my_auth_2` sont arbitraires et peuvent prendre n'importe quelle valeur.\n\n### Utilisateur\n\nUn utilisateur (username, password facultatif) est utilisÃ© pour se connecter Ã  RabbitMQ afin de publier et consommer les messages.\n\n> Le plugin `rabbitmq_management` ajoute une notion de tags (administrator, monitoring, policymaker, management, impersonator)\n> afin de limiter l'accÃ¨s aux diffÃ©rentes parties de l'interface.\n\nUne fois votre utilisateur crÃ©Ã©, il faudra lui ajouter des permissions sur chaque `vhost` auxquels il aura accÃ¨s.\n\nSur le backend d'auth par dÃ©faut (`rabbit_auth_backend_internal`), les permissions sont sÃ©parÃ©es en 3 groupes :\n\n * Configure regexp\n * Write regexp\n * Read regexp\n\n![RabbitMQ Permissions]({{site.baseurl}}/assets/2018-04-11-rabbitmq-partie-2-la-maitrise/rabbitmq-permissions.png)\n\n> ğŸš€ Pour une utilisation plus simple des regexp je vous conseille d'avoir une vraie stratÃ©gie de nommage des `exchanges`/`queues`\n> avec des prÃ©fixes/segments/suffixes. D'une part vous pourrez plus facilement identifier qui a crÃ©Ã© les ressources mais aussi qui les consomme.\n\nJe vous laisse consulter le [tableau de rÃ©partition des actions par ressource](http://www.rabbitmq.com/access-control.html#permissions)\n\n> ğŸ¥• Maintenant vous pouvez facilement identifier vos petits lapins.\n\n## Policies\n\nLes policies sont des rÃ¨gles de configurations qui s'appliquent aux `exchanges` et aux `queues` (dont le nom matche une regexp) afin de diminuer la redondance de configuration mais aussi et surtout de pouvoir changer une `policy` sans avoir Ã  dÃ©truire et recrÃ©er la ressource (`exchange`/`queue`).\nCertaines options de configuration d'une `policy` sont spÃ©cifiques aux `exchanges` et d'autres aux `queues`.\n\n![RabbitMQ Policies]({{site.baseurl}}/assets/2018-04-11-rabbitmq-partie-2-la-maitrise/rabbitmq-policies.png)\n\nLes `Policies` peuvent Ãªtre utilisÃ©es pour configurer :\n\n- [federation plugin](https://www.rabbitmq.com/federation.html)\n- [mirrored queues](https://www.rabbitmq.com/ha.html)\n- [alternate exchanges](https://www.rabbitmq.com/ae.html)\n- [dead lettering](https://www.rabbitmq.com/dlx.html)\n- [per-queue TTLs](https://www.rabbitmq.com/ttl.html)\n- [maximum queue length](https://www.rabbitmq.com/maxlength.html).\n\n> âš ï¸  Attention, l'utilisation de policies peut devenir rapidement complexe.\n\n## Retry (Dead letter)\n\nLes retries sont un autre sujet **trÃ¨s important** de RabbitMQ ! Quand le message consumer rencontre une erreur durant le traitement d'un message il peut Ãªtre intÃ©ressant dans certains cas de rÃ©essayer le traitement du message.\nLes diffÃ©rentes solutions sont :\n\n- Ne pas ACK ou NACK le message (Retry infini instantanÃ© bloquant)\n\n> Le message va garder sa place dans la queue et le consumer va de nouveau rÃ©cupÃ©rer ce message au prochain get.\n> âš ï¸ Je dÃ©conseille *trÃ¨s fortement* cette approche ! Car le consumer va toujours rÃ©cupÃ©rer le mÃªme message jusqu'au succÃ¨s du traitement,\n> qui pourrait ne jamais se produire et crÃ©er une boucle infinie. De plus le message en erreur bloque le dÃ©pilement des messages suivants.\n\n- NACK le message avec une queue configurÃ©e avec DLX = \"\" (default exchange amq.default) et DLK = {QUEUENAME}  (Retry infini instantanÃ© non bloquant)\n\n> Le message va Ãªtre remis en dÃ©but de queue.\n> âš ï¸ Je dÃ©conseille Ã©galement cette approche ! Cette fois-ci, le message ne va pas bloquer le dÃ©pilement des autres messages de la queue,\n> mais il peut quand mÃªme crÃ©er une boucle infinie si il n'y a qu'un message dans la queue.\n\n- ACK le message aprÃ¨s avoir publiÃ© un clone du message depuis le consumer. (Solution la plus dynamique -> retry retardÃ© *variable* non bloquant)\n\n> â„¹ï¸ Avec cette solution on peut facilement gÃ©rer des \"dÃ©lais avant retry\" variables. Premier retry Ã  5 secondes, deuxiÃ¨me Ã  10 secondes, etc...\n> âš ï¸ Je garde une rÃ©serve sur cette pratique car elle fonctionne mais positionne la responsabilitÃ© du retry du cÃ´tÃ© applicatif.\n\n- NACK le message avec un dÃ©lai avant de retry le message (Le \"dÃ©lai avant retry\" est fixe -> retry retardÃ© *fix* non bloquant)\n\n> ğŸ‘ Le message va Ãªtre remis en dÃ©but de queue aprÃ¨s avoir Ã©tÃ© mis en attente pendant un temps dÃ©fini.\n\nC'est cette derniÃ¨re solution que nous allons dÃ©tailler.\n\nPour mettre en place cette solution nous allons devoir crÃ©er un exchange et une queue d'attente.\n\nCrÃ©er un exchange qui va router les messages dans la queue d'attente `waiting_5` type `fanout`.\nCrÃ©er une queue d'attente `waiting_5` avec `x-dead-letter-exchange: \"\"` et `x-message-ttl: 5000`.\nPuis binder cette queue sur l'exchange `waiting_5`.\n\n> âš ï¸ le x-dead-letter-exchange doit Ãªtre configurÃ© avec une chaÃ®ne vide (amq.default).\n\nConfigurez ensuite votre queue `queue1` avec `x-dead-letter-exchange: \"waiting_5\"` `x-dead-letter-routing-key: queue1`.\n\n> âš ï¸ le x-dead-letter-routing-key doit Ãªtre configurÃ© avec le nom de la queue.\n\n![RabbitMQ Retry]({{site.baseurl}}/assets/2018-04-11-rabbitmq-partie-2-la-maitrise/rabbitmq-retry.jpg)\n\nAvec cette configuration, quand le consumer NACK le message, RabbitMQ redirige le message dans l'exchange `waiting_5` (fanout)\nqui va donc router ce message dans la queue `waiting_5`. La queue `waiting_5` va attendre 5 secondes avant d'`expired` le message,\nil va donc arriver dans l'exchange `amq.default` avec comme routing key `queue1` et donc Ãªtre routÃ© dans la queue `queue1`.\n\n> â„¹ï¸ Ã€ noter que le retry est infini. Ce qui peu Ã©galement crÃ©er des `poison messages`.\n\n## Poison message\n\nUn `poison message` c'est un message que le consumer rejettera (NACK) Ã  chaque fois qu'il va le consommer.\nAfin de traiter les poisons messages il faut que le consumer regarde dans les properties du message afin de vÃ©rifier\nque le nombre de tentatives n'a pas Ã©tÃ© atteint.\n\n![RabbitMQ Retry]({{site.baseurl}}/assets/2018-04-11-rabbitmq-partie-2-la-maitrise/rabbitmq-x-death-header.jpg)\n\n> Si le nombre de retry a Ã©tÃ© atteint il faudra loguer une erreur et ACK le message.\n\n## Production\n\nConsultez la documentation sur les [recommandations pour les serveurs de **production**](https://www.rabbitmq.com/production-checklist.html).\n\n> ğŸ‡ Vous voici maintenant fin prÃªt Ã  dÃ©guster un bon pÃ¢tÃ© de lapin !\n\n## Liens utiles\nhttps://www.rabbitmq.com/admin-guide.html\n"}