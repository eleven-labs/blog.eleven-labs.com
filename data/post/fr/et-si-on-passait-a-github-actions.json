{"date":"2022-01-13T00:00:00.000Z","title":"Et si on passait √† Github Actions ?","excerpt":"On parle souvent de Gitlab CI ou Drone CI, mais qu'en est-il de Github Actions ? Petit retour sur ce qu'on peut faire avec et comment l'utiliser.","readingTime":"28mn","authors":["larcheops"],"categories":["architecture"],"content":"\nPendant presque une d√©cennie, Gitlab a su s'imposer comme forge logicielle, notamment gr√¢ce √† sa CI _(ou Continuous Integration)_ performante, flexible et facile d'utilisation. Cependant, en fin d'ann√©e 2019, Github a lanc√© sa propre CI/CD avec une int√©gration unique √† la plateforme : les _Github Actions_.\n\nDans cet article, nous allons survoler la syntaxe des Github Actions en construisant au fur et √† mesure notre premier _workflow_. Le but de ce dernier sera de valider une modification sur des fichiers Terraform lors d'une _pull request_ (ou _PR_).\n\n> NOTE : je vais utiliser quelques termes qui font r√©f√©rence √† Terraform. Leur compr√©hension n'est pas n√©cessaire pour comprendre cet article.\n\nMais avant toute chose, qu'est-ce que la CI/CD ?\n\n## Rappel : qu'est-ce que la CI/CD ?\n\nCommen√ßons avec une notion indispensable, celle de CI/CD. Tout comme pour notre pr√©c√©dent article *[Introduction √† Gitlab CI](https://blog.eleven-labs.com/fr/introduction-gitlab-ci/)*, je ne vais pas vous faire une √©ni√®me d√©finition de ce qu'est la *CI/CD* mais utiliser √† la place deux d√©finitions, de chez Atlassian :\n\n> **TLDR;**  \n> **Int√©gration continue** : ensemble de tests et proc√©dures lanc√©es automatiquement √† la suite de changements de la base de code.  \n> **D√©ploiement continu** : ensemble de proc√©dures lanc√©es automatiquement dans le but de d√©ployer la base de code en production.\n\n### Continuous Integration (CI)\n\n> L'int√©gration continue (CI) d√©signe la pratique qui consiste √† **automatiser l'int√©gration des changements de code** r√©alis√©s par plusieurs contributeurs dans un seul et m√™me projet de d√©veloppement.  \n> Il s'agit d'une bonne pratique DevOps principale, permettant aux d√©veloppeurs de logiciels de **merger fr√©quemment des changements de code** dans un d√©p√¥t central o√π les builds et les tests s'ex√©cutent ensuite.  \n> *Atlassian, https://www.atlassian.com/fr/continuous-delivery/continuous-integration*\n\n### Continuous Deployment (CD)\n\n> La livraison continue est une m√©thode de d√©veloppement de logiciels dans le cadre de laquelle les modifications de code **sont automatiquement pr√©par√©es en vue de leur publication** dans un environnement de production.  \n> V√©ritable pilier du d√©veloppement moderne d'applications, **la livraison continue √©tend le principe de l'int√©gration continue** en d√©ployant tous les changements de code dans un environnement de test et/ou de production apr√®s l'√©tape de cr√©ation.  \n> Lorsque la livraison continue est correctement impl√©ment√©e, les d√©veloppeurs **disposent en permanence d'un artefact de g√©n√©ration pr√™t pour le d√©ploiement** qui a √©t√© soumis avec succ√®s √† un processus de test standardis√©.  \n> *Amazon web services, https://aws.amazon.com/fr/devops/continuous-delivery/*\n\nMaintenant que nous nous sommes un peu plus familiaris√©s avec le concept de CI/CD, il est temps de rentrer dans le vif du sujet !\n\n## Qu'est-ce que Github Actions ?\n\nComme expliqu√© pr√©c√©demment, **Github Action** est l'outil de CI/CD directement int√©gr√© √† Github, sorti fin 2019. L√† o√π il fallait avant utiliser des services externes comme _Drone.io_ ou _TravisCI_ pour ne citer qu'eux, Github Action est directement int√©gr√© √† la plateforme Github.\n\nDe plus, du fait de son int√©gration compl√®te avec Github, il peut √©galement vous aider √† automatiser certains de vos workflows directement au sein de Github. La liste des √©v√®nements permettant de d√©clencher un workflow est longue, mais en voici quelques exemples :\n\n- Cr√©ation ou modification d'une PR (nouveau commentaire par exemple)\n- Push sur une branche pr√©cise\n- Changement de status d'une _issue_ Github\n- D√©clenchement manuel\n- Modification quelconque d'un ticket sur un _projet board_ dans Github\n\nCependant, pour moi, la vraie force des _Github Actions_ provient de son m√©canisme de composants r√©utilisables : les **Actions**.\n\nIl s'agit de composants logiques, souvent avec du code en amont, permettant d'effectuer certaines t√¢ches. L√† o√π on devait int√©grer Terraform dans son image de CI ou l'installer depuis un script, on peut d√©sormais utiliser [l'action officielle](https://github.com/hashicorp/setup-terraform) avec un simple `uses: hashicorp/setup-terraform@v1`.\n\nEt depuis d√©but Octobre 2021 (voir leur [blog post](https://github.blog/changelog/2021-10-05-github-actions-dry-your-github-actions-configuration-by-reusing-workflows/)), il est m√™me possible de r√©utiliser des workflows complet.\n\nOn en a souvent parl√© dans ce d√©but d'article, mais qu'est-ce qu'un workflow ?\n\n## Les workflows\n\nUn workflow est une proc√©dure automatis√©e compos√©e d'une ou plusieurs √©tapes. C'est un peu la d√©finition compl√®te de ce que l'on cherche √† accomplir √©crite en YAML.\n\nLa syntaxe de l'objet racine est la suivante :\n\n- `name` : nom du workflow, qui sera √©galement visible sur l'interface Github\n  (comme dans https://github.com/actions/runner/actions)\n- `on` : objet contenant les diff√©rents d√©clencheurs du\n  workflow ([liste des √©v√®nements disponibles](https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows))\n- `jobs` : d√©finitions du comportement du workflow\n\n> Il existe d'autres champs, mais nous n'en parlerons pas dans cet article.\n> Cependant, la documentation officielle est relativement bien faite et je vous y invite √† la lire pour plus d'informations : https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions\n\nRevenons √† notre workflow. Celui-ci devra se d√©clencher uniquement lorsqu'on cr√©e une PR ou lorsqu'on met √† jour ce dernier en rajoutant un nouveau commit.\nPour cela, il faut utiliser le d√©clencheur [`pull_request`](https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows#pull_request). Par d√©faut, celui-ci sera lanc√© lorsqu'on cr√©e la PR (`opened`), qu'on fait un push dessus (`synchronize`) ou lorsqu'on rouvre une PR (`reopened`).\n\n```yaml\nname: Terraform CI\n\non:\n  pull_request:\n  # types: [opened, synchronize, reopened] # valeur par d√©faut, qu'on peut donc omettre\n```\n\nMaintenant qu'on a determin√© quand d√©clencher le `workflow`, il est temps d'en venir au corps du workflow : les `jobs`.\n\n## Les jobs\n\nIl faut visualiser un workflow comme un graphe ; nous avons une suite d'actions que l'on appelle un `job` qui peut en appeller d'autres √† la fin de son ex√©cution, qui √† leur tour peuvent en ex√©cuter d'autres, jusqu'√† ce que l'objectif du workflow soit atteint.\n\nPar exemple, nous pouvons voir notre workflow `Terraform CI` comme 2 suites d'actions (ou `jobs`) distinctes :\n\n- V√©rifier que les fichiers soient normalis√©s et qu'ils ne contiennent pas d'erreur de syntaxe (`lint`)\n- G√©n√©rer un plan d'ex√©cution des modifications Terraform (https://www.terraform.io/cli/commands/plan#command-plan)\n\nPour chacun de ces _jobs_, il y a quelques champs obligatoires √† d√©finir :\n\n- D√©finir sur quelle machine les actions vont √™tre ex√©cut√©es (ces `runners` sont soit [des machines fournies par Github](https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#github-hosted-runners) soit nos propres machines) (`runs-on`)\n- La liste des actions √† ex√©cuter (`steps`)\n\nIl existe √©galement d'autres champs pour permettre une configuration plus approfondie, dont voici une liste non exhaustive :\n\n- Le nom dudit _job_ (`name`) _(bien qu'optionnel, je conseille fortement de quand m√™me de le d√©finir)_\n- De possibles d√©pendances vers d'autres `jobs` (`needs`)\n- Des conditions (`if`)\n- Diff√©rentes strat√©gies d'ex√©cution en parall√®le (`strategy` et `concurrency`). Ce sont d'ailleurs ces strat√©gies qui nous permettent d'utiliser ce qu'on appelle des matrices de build (g√©n√©rer plusieurs fois le m√™me `job` avec un ou plusieurs param√®tres changeant)\n\nLa liste compl√®te est d√©finie dans la documentation.\n\nConcernant notre workflow, d√©coupons un peu ces deux `jobs`:\n\n- Le premier, `lint` permettra de valider le format et la syntaxe de nos modifications Terraform. Le plus commun et de faire tourner ces actions sur le _runner_ `ubuntu-latest`.\n- Concernant le second, le `plan`, √ßa sera un peu plus complexe. On souhaite le faire tourner uniquement si le _job_ `lint` a r√©ussi. De plus, pour √©viter tout probl√®me de concurrence entre deux `plan` Terraform, il faudrait √©viter d'en lancer deux en m√™me temps. Enfin, tout comme le premier, on souhaiterait le lancer sur `ubuntu-latest`\n\nCes besoins se traduisent ainsi :\n\n```yaml\njobs:\n  lint:\n    name: Format & validate Terraform files\n    runs-on: ubuntu-latest\n    steps: []\n  plan:\n    name: Generates a speculative execution plan\n    runs-on: ubuntu-latest\n    needs: [lint] # on ex√©cute ce job uniquement si le pr√©c√©dent a r√©ussi\n    concurrency: tf-plan # nous d√©finissons la cl√© `tf-plan` afin d'√©viter de lancer en parall√®le tout autre job utilisant cette m√™me cl√© (ici, le job `plan`)\n    steps: []\n```\n\nMaintenant que nous avons d√©finit comment nos _jobs_ vont √™tre ex√©cut√©, il est temps de d√©finir ce qu'ils vont ex√©cuter au travers des `steps`.\n\n## Les steps\n\nUn `step` n'est rien d'autre qu'une t√¢che unitaire n√©cessaire pour effectuer le _job_. √áa peut √™tre du code shell ou du python, mais √©galement des `actions` ; c'est l√† la force de _Github Actions_.\n\n## Les actions\n\nLes `actions` sont des _applications_ pour _Github Actions_ ex√©cutant des t√¢ches complexes, mais r√©p√©titives. L√† o√π l'on devait avant cr√©er du code personnalis√© pour effectuer des √©tapes r√©p√©titives (comme Jenkins) ou importer des blocks d'ex√©cutions non param√©trables (`include` + `extends` sous Gitlab CI/CD), les `actions` permettent cela nativement et facilement.\n\nEn effet, l'un des plus gros avantages des `actions` est qu'elles peuvent √™tre g√©r√©es directement par la communaut√©. Gr√¢ce √† cela, plus besoin de maintenir la compatibilit√© de nos scripts... √† condition que la communaut√© en question y fasse attention √©galement. Par exemple, dans notre cas d'exemple, nous allons utiliser des `actions` directement issues des repos de Hashicorp ; nous sommes donc s√ªrs que ces `actions` seront mises √† jour et suivront l'√©volution de Terraform.\n\nCependant, les `actions` viennent √©galement avec leurs lots de contraintes. La premi√®re est bien √©videmment l'abstraction ; en utilisant des composants externes, on ne sait pas exactement ce qui est ex√©cut√©, ni comment. Si quelque chose ne fonctionne pas, il peut √©galement √™tre compliqu√© d'investiguer et d'en connaitre la raison.\nLa seconde, qui r√©sulte de la premi√®re, est un risque pour la s√©curit√©. Du fait qu'il y ait de l'abstraction et que les `actions` soient cr√©√©es et g√©r√©es par des personnes externes ajoute un risque de s√©curit√© suppl√©mentaire, comme la fuite de code source ou l'injection de faille lors de la compilation. Ce risque est notamment accru si on les utilise √† tort et √† travers.\nBien heureusement, il existe des moyens de mitiger au mieux ce probl√®me en suivant quelques bonnes pratiques.\n\n### D√©finitions des steps avec les _actions_\n\nComme pour les `jobs` il y a quelques champs requis pour ex√©cuter une action au sein d'un _step_ :\n\n- La description de l'√©tape (`name`). Comme pour les `jobs`, c'est optionnel, mais √ßa facilite grandement la lecture des logs dans Github. C'est pourquoi je vous le conseille vivement dans la majorit√© des cas.\n- L'action qu'on souhaite utiliser, en pr√©cisant sa version (`uses`). Par exemple, pour cloner le repo sur la bonne branche, on va utiliser g√©n√©ralement [`actions/checkout@v2`](https://github.com/actions/checkout).\n- Les param√®tres si l'action en a besoin (`with`). Cela n'est pas toujours requis ; par exemple `actions/checkout@v2` va utiliser le contexte fourni par Github pour d√©terminer quel repo cloner et quelle branche utiliser.\n  _Nous reparlerons du contexte plus tard._\n\nEn voici quelques exemples :\n\n```yaml\n- name: Checkout repository code\n  uses: actions/checkout@v2\n- name: Setup Terraform 1.1.2\n  uses: hashicorp/setup-terraform@3d8debd658c92063839bc97da5c2427100420dec # nous pouvons √©galement utiliser le SHA d'un commit en particulier (ici, celui de la v1.3.2)\n  with:\n    terraform_version: 1.1.2\n```\n\n### D√©finitions des steps sans les _actions_\n\nDans certains cas, nous n'avons pas vraiment besoin d'utiliser des `actions` pour arriver √† nos fins. Dans ces cas-l√†, nous pouvons directement ex√©cuter du code shell ou python. Pour cela, il suffit d'utiliser `run` dans la d√©finition du `step`.\n\nEn voici quelques exemples :\n\n```yaml\n- name: Debug environment\n  run: env\n- name: Rewrites all Terraform configuration files to a canonical format\n  run: terraform fmt .\n```\n\n### Les contextes\n\nLes contextes sont un moyen d'acc√©der √† des informations √† propos du workflow en cours, de l'environnement d'ex√©cution ou des pr√©c√©dents `jobs` et `steps` ex√©cut√©s.\n> Attention, comme pr√©cis√© dans la documentation, les contextes **peuvent √™tre manipul√©s et doivent √™tre trait√©s comme sources pouvant contenir des informations malicieuses**\n\nL'acc√®s √† ces informations se fait au travers de la syntaxe `${{ context }}`. Je ne vais pas en parler directement dans cet article, car la documentation en parlera probablement mieux que moi et qu'il y a beaucoup de chose √† dire dessus. Voici les deux pages de documentation que je vous conseille si vous voulez approfondir ce sujet :\n\n- Les contextes : [https://docs.github.com/en/actions/learn-github-actions/contexts](https://docs.github.com/en/actions/learn-github-actions/contexts)\n- La syntaxe et les outils associ√©s avec : [https://docs.github.com/en/actions/learn-github-actions/expressions](https://docs.github.com/en/actions/learn-github-actions/expressions)\n\n### D√©finitions des steps\n\nOn a vu pr√©c√©demment les deux fa√ßons d'√©crire des `step` ; il est donc temps de revenir sur notre workflow. Mais juste avant, tout comme les `workflows` et les `jobs`, les `steps` ont quelques champs optionnels que voici :\n\n- Des conditions (`if`)\n- Ajouter des variables d'environnement (`env`).\n  _Je ne l'ai pas pr√©cis√© avant, mais il est √©galement possible de faire √ßa au niveau d'un `job` complet ou m√™me du workflow._\n- Ajouter un identifiant √† un `step` (`id`). Cela permet de pouvoir utiliser les retours d'une `action` depuis le contexte, ou d'avoir une condition sur l'√©tat d'ex√©cution d'un `step` pr√©c√©dent.\n\nIl y en quelques autres qu'on ne verra pas dans cet article. Mais comme toujours, la documentation officielle est tr√®s bien fournie.\n\nCommen√ßons par notre premier job : `lint`\n\n#### D√©finition des steps pour le premier job _(lint)_\n\nComme d√©finit pr√©c√©demment, notre premier `job` est charg√© de v√©rifier la syntaxe et le formatage des fichiers Terraform. Pour cela, nous allons utiliser deux commandes incluses dans le CLI de Terraform : `terraform fmt` et `terraform validate`.\n\nVoici donc les diff√©rentes √©tapes :\n\n- On clone le repository sur la branche correspondant √† la PR\n    - `uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579`\n- On installe la commande `terraform` pour pouvoir l'utilser dans les √©tapes suivantes\n    - `uses: hashicorp/setup-terraform@3d8debd658c92063839bc97da5c2427100420dec`\n- On initialise Terraform (requis pour le terraform validate)\n    - `run: terraform init -no-color -backend=false`\n        - On utilise `-backend=false` ici, car on ne fait le `init` ici que pour t√©l√©charger toutes les d√©pendances requises pour le `terraform validate`\n- On v√©rifie que la syntaxe des fichiers Terraform est bonne\n    - `run: terraform validate -no-color`\n- On v√©rifie que les fichiers Terraform sont bien format√©s\n    - `run: terraform fmt -check -recursive -diff -no-color .`\n\n\n![Premier job: lint](/imgs/posts/2022-01-13-et-si-on-passait-a-github-actions/github-actions-lint.png)\n\n\nVoici donc la d√©finition YAML de notre premier `job` :\n\n```yaml\nlint:\n  name: Format & validate Terraform files\n  runs-on: ubuntu-latest\n  steps:\n    - name: Checkout repository code\n      uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579\n    - name: Setup Terraform 1.1.2\n      uses: hashicorp/setup-terraform@3d8debd658c92063839bc97da5c2427100420dec\n    - name: Initialize Terraform working directory\n      run: terraform init -no-color -backend=false\n    - name: Validate the configuration files\n      run: terraform validate -no-color\n    - name: Check if all Terraform configuration files are in a canonical format\n      run: terraform fmt -check -recursive -diff -no-color\n```\n\nPassons maintenant au second `job` : `plan`\n\n#### D√©finition des steps pour le second job _(plan)_\n\nLa seule diff√©rence avec le premier est l'utilisation de `terraform plan`.\n\nVoici donc les diff√©rentes √©tapes pour le second :\n\n- On clone le repository sur la branche correspondant √† la PR\n    - `uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579`\n- On configure la CI pour utiliser Terraform\n    - `uses: hashicorp/setup-terraform@3d8debd658c92063839bc97da5c2427100420dec`\n- On initialise Terraform (requis pour le terraform validate)\n    - `run: terraform init -no-color`\n- On fait un plan pour visualiser les changements.\n    - `run: terraform plan -input=false -no-color -compact-warnings`\n\n\n![Second job: plan](/imgs/posts/2022-01-13-et-si-on-passait-a-github-actions/github-actions-plan.png)\n\n\nVoici donc la d√©finition YAML de notre second `job`\n\n```yaml\nplan:\n  name: Generates a speculative execution plan\n  runs-on: ubuntu-latest\n  needs: [lint] # on ex√©cute ce job uniquement si le pr√©c√©dent a r√©ussi\n  concurrency: tf-plan # on fait en sorte d'√©viter toute concurrence lors du Terraform plan\n  steps:\n    - name: Checkout repository code\n      uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579\n    - name: Setup Terraform 1.1.2\n      uses: hashicorp/setup-terraform@3d8debd658c92063839bc97da5c2427100420dec\n    - name: Initialize Terraform working directory\n      env:\n        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n      run: terraform init -no-color\n    - name: Generate a speculative execution plan\n      # S'il y a besoin d'utiliser des variables, c'est faisable via les variables d'environnement\n      # env:\n      #   TF_VARS_...: ...\n      run: terraform plan -input=false -no-color -compact-warnings\n```\n\n> `${{ secrets.AWS_ACCESS_KEY_ID }}` permet d'utiliser des variables donc le contenu peut √™tre sensible. Ce valeurs sont configurables directement dans Github et leur valeur ne seront jamais affich√©es dans les logs de la CI.\n\n#### D√©finition de notre workflow\n\nMaintenant que les `jobs` et `steps` ont √©t√© d√©fini, il est temps d'assembler les diff√©rentes parties pour obtenir notre workflow final :\n\n```yaml\nname: Terraform CI\n\non:\n  pull_request:\n\njobs:\n  lint:\n    name: Format & validate Terraform files\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository code\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579\n      - name: Setup Terraform 1.1.2\n        uses: hashicorp/setup-terraform@3d8debd658c92063839bc97da5c2427100420dec\n      - name: Initialize Terraform working directory\n        run: terraform init -no-color -backend=false\n      - name: Validate the configuration files\n        run: terraform validate -no-color\n      - name: Check if all Terraform configuration files are in a canonical format\n        run: terraform fmt -check -recursive -diff -no-color\n\n  plan:\n    name: Generates a speculative execution plan\n    runs-on: ubuntu-latest\n    needs: [lint] # on ex√©cute ce job uniquement si le pr√©c√©dent a r√©ussi\n    concurrency: tf-plan # on fait en sorte d'√©viter toute concurrence lors du Terraform plan\n    steps:\n      - name: Checkout repository code\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579\n      - name: Setup Terraform 1.1.2\n        uses: hashicorp/setup-terraform@3d8debd658c92063839bc97da5c2427100420dec\n      - name: Initialize Terraform working directory\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        run: terraform init -no-color\n      - name: Generate a speculative execution plan\n        # S'il y a besoin d'utiliser des variables, c'est faisable via les variables d'environnement\n        # env:\n        #   TF_VARS_...: ...\n        run: terraform plan -input=false -no-color -compact-warnings\n```\n\n## Quelques bonnes pratiques\n\nAvant de conclure cet article, j'aimerais partager avec vous ces quelques bonnes pratiques qui vous permettront de r√©duire au mieux les inconv√©nients des Github Actions\n\n1. Toujours utiliser un SHA de commit au lieu d'une version lors de l'utilisation d'actions.\n   Par exemple, au lieu de faire `uses: actions/checkout@v2`, faites plut√¥t `uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579`.\n   Cela permet d'√™tre toujours s√ªr de savoir quelle version du code on utilise et ainsi de faciliter l'audit dessus.\n2. Si possible, v√©rifier le code source d'une action avant de l'utiliser, toujours pour r√©duire au mieux les possibles risques de s√©curit√©.\n3. Ne pas utiliser de secret en clair dans la d√©finition des workflows. √Ä la place, il faut utiliser la gestion de secrets dans Github en utilisant la syntaxe `${{ secret.NOM_DU_SECRET }}`. La d√©finition des secrets se fait dans la configuration du repository ou dans celle de l'organisation (pour des secrets partag√©s entre plusieurs repos d'une organisation)\n\n## Conclusion\n\nNous avons pu construire notre premier workflow tout au long de cet article, en voyant les diff√©rents concepts que sont les `workflows`, les `jobs` ainsi que les `steps`. Nous avons fait un tour rapide de la syntaxe de chacun et parl√© des quelques bonnes pratiques. Mais malgr√© cela, nous n'avons qu'effleur√© la surface des possibilit√©s (et de la complexit√©) des Github Actions et il reste tant de choses √† voir, comme son utilisation pour la gestion des tickets par exemple (attribuer des √©tiquettes automatiquement, fermer des issues/PRs trop anciennes...).\n\n## BONUS : un petit commentaire dans la PR ?\n\nLe workflow cr√©√© dans cet article est pratique, mais quelque peu aust√®re ; s'il y a un probl√®me, le workflow √©choue et nous force √† aller chercher dans les logs du workflow pour savoir pourquoi.\nPourquoi ne pas commenter la PR avec la source du probl√®me ? Et pourquoi ne pas rajouter le plan au passage ? C'est ce que je vais vous montrer en utilisant l'action [`marocchino/sticky-pull-request-comment`](https://github.com/marocchino/sticky-pull-request-comment):\n\n```yaml\nname: Terraform CI\n\non:\n  pull_request:\n\njobs:\n  lint:\n    name: Format & validate Terraform files\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository code\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579\n      - name: Setup Terraform 1.1.2\n        uses: hashicorp/setup-terraform@3d8debd658c92063839bc97da5c2427100420dec\n\n      - name: Initialize Terraform working directory\n        id: init\n        run: terraform init -no-color -backend=false\n      - name: Annotate the PR if the previous step fail\n        if: failure() && steps.init.outcome == 'failure' # on commente uniquement si le step avec l'id `init` √©choue\n        uses: marocchino/sticky-pull-request-comment@39c5b5dc7717447d0cba270cd115037d32d28443\n        with:\n          recreate: true\n          message: |\n            # Terraform CI\n            - [ ] :hammer_and_wrench: Validate the configuration files\n            ### üö´ Failure reason\n            ```terraform\n            ${{ steps.init.outputs.stdout }}\n            ```\n            <br/>\n            > _Report based on commit ${{ github.sha }} (authored by **@${{ github.actor }}**).  See [`actions#${{ github.run_id }}`](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for more details._\n\n\n      - name: Validate the configuration files\n        id: validate\n        run: terraform validate -no-color\n      - name: Annotate the PR if the previous step fail\n        if: failure() && steps.validate.outcome == 'failure' # on commente uniquement si le step avec l'id `validate` √©choue\n        uses: marocchino/sticky-pull-request-comment@39c5b5dc7717447d0cba270cd115037d32d28443\n        with:\n          recreate: true\n          message: |\n            # Terraform CI\n            - [ ] :hammer_and_wrench: Validate the configuration files\n            ### üö´ Failure reason\n            ```terraform\n            ${{ steps.validate.outputs.stdout }}\n            ```\n            <br/>\n            > _Report based on commit ${{ github.sha }} (authored by **@${{ github.actor }}**).  See [`actions#${{ github.run_id }}`](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for more details._\n\n      - name: Check if all Terraform configuration files are in a canonical format\n        id: fmt\n        run: terraform fmt -check -recursive -diff -no-color\n      - name: Annotate the PR if the previous step fail\n        if: failure() && steps.fmt.outcome == 'failure' # on commente uniquement si le step avec l'id `fmt` √©choue\n        uses: marocchino/sticky-pull-request-comment@39c5b5dc7717447d0cba270cd115037d32d28443\n        with:\n          recreate: true\n          message: |\n            # Terraform CI\n            - [x] :hammer_and_wrench: Validate the configuration files\n            - [ ] :paintbrush: Check if all Terraform configuration files are in a canonical format\n            ### üö´ Failure reason\n            ```terraform\n            ${{ steps.fmt.outputs.stdout }}\n            ```\n            <br/>\n            > _Report based on commit ${{ github.sha }} (authored by **@${{ github.actor }}**).  See [`actions#${{ github.run_id }}`](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for more details._\n\n  plan:\n    name: Generates a speculative execution plan\n    runs-on: ubuntu-latest\n    needs: [lint] # on ex√©cute ce job uniquement si le pr√©c√©dent a r√©ussi\n    concurrency: tf-plan # on fait en sorte d'√©viter toute concurrence lors du Terraform plan\n    steps:\n      - name: Checkout repository code\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579\n      - name: Setup Terraform 1.1.2\n        uses: hashicorp/setup-terraform@3d8debd658c92063839bc97da5c2427100420dec\n\n      - name: Initialize Terraform working directory\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        id: init\n        run: terraform init -no-color\n      - name: Annotate the PR if the previous step fail\n        if: failure() && steps.init.outcome == 'failure' # on commente uniquement si le step avec l'id `init` √©choue\n        uses: marocchino/sticky-pull-request-comment@39c5b5dc7717447d0cba270cd115037d32d28443\n        with:\n          recreate: true\n          message: |\n            # Terraform CI\n            - [x] :hammer_and_wrench: Validate the configuration files\n            - [x] :paintbrush: Check if all Terraform configuration files are in a canonical format\n            - [ ] :scroll: Generate a speculative execution plan\n            ### üö´ Failure reason\n            ```terraform\n            ${{ steps.init.outputs.stdout }}\n            ```\n            <br/>\n            > _Report based on commit ${{ github.sha }} (authored by **@${{ github.actor }}**).  See [`actions#${{ github.run_id }}`](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for more details._\n\n      - name: Generate a speculative execution plan\n        id: plan\n        run: terraform plan -input=false -no-color -compact-warnings\n      - name: Annotate the PR if the previous step fail\n        if: failure() && steps.plan.outcome == 'failure' # on commente uniquement si le step avec l'id `plan` √©choue\n        uses: marocchino/sticky-pull-request-comment@39c5b5dc7717447d0cba270cd115037d32d28443\n        with:\n          recreate: true\n          message: |\n            # Terraform CI\n            - [x] :hammer_and_wrench: Validate the configuration files\n            - [x] :paintbrush: Check if all Terraform configuration files are in a canonical format\n            - [ ] :scroll: Generate a speculative execution plan\n            ### üö´ Failure reason\n            ```terraform\n            ${{ steps.plan.outputs.stdout }}\n            ```\n            <br/>\n            > _Report based on commit ${{ github.sha }} (authored by **@${{ github.actor }}**).  See [`actions#${{ github.run_id }}`](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for more details._\n\n      - name: Annotate the PR if the plan step succeed\n        if: success() # on commente uniquement tout a r√©ussi\n        uses: marocchino/sticky-pull-request-comment@39c5b5dc7717447d0cba270cd115037d32d28443\n        with:\n          recreate: true\n          message: |\n            # Terraform CI\n            - [x] :hammer_and_wrench: Validate the configuration files\n            - [x] :paintbrush: Check if all Terraform configuration files are in a canonical format\n            - [x] :scroll: Generate a speculative execution plan\n            ### Terraform Plan output\n            ```terraform\n            ${{ steps.plan.outputs.stdout }}\n            ```\n            <br/>\n            > _Report based on commit ${{ github.sha }} (authored by **@${{ github.actor }}**).  See [`actions#${{ github.run_id }}`](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for more details._\n```\n\nC'est tr√®s verbeux, mais cela facilite grandement la review de PRs car on sait exactement pourquoi le workflow √©choue ou quelles vont √™tre les modifications sur l'infrastructure.\n\n## Ressources\n\n- [Github Actions](https://github.com/features/actions)\n- [Github Actions syntaxe](https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions)\n- [Github Actions d√©clencheurs](https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows)\n- [Blog Github](https://github.blog/)\n\n"}