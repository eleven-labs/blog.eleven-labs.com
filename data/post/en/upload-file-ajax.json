{"date":"2017-04-20T00:00:00.000Z","title":"Upload file with AJAX","excerpt":"Today, I would like to share with you a feature often requested in an application: uploading a file.","readingTime":"8mn","authors":["tthuon"],"categories":["php"],"content":"\nToday, I would like to share with you a feature often requested in an application: uploading a file.\nVery often, the upload of a file is done via a form in html with the attribute **enctype=\"multipart/form-data\"**. Then the form is posted to the server. But when a file weighs several megabytes, or several gigabytes, the user waits without any response from server during file uploading.\n\nThis is where AJAX comes in! (Wouhou!) It will both allow us to make this upload as asynchronous and allow to have information about its state.\n\nLet's see how to implement a file upload system in JavaScript and with Symfony in server-side.\n\n### Implementing the Symfony form\n\nMy form will contain two fields: **name** and **file**. The first one will contain the name of the file that the user wants to give. The second will be the representation of the file via the **Symfony\\Component\\HttpFoundation\\File\\UploadedFile** object.\n\nSymfony has a **FormType** that is **FileType**. As the name suggests, it allows you to manage a form field of file type.\n\n```php\n<?php\n// src/AppBundle/Form/UploadType.php\nnamespace AppBundle\\Form;\n\nuse Symfony\\Component\\Form\\AbstractType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\FileType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType;\nuse Symfony\\Component\\Form\\FormBuilderInterface;\nuse Symfony\\Component\\OptionsResolver\\OptionsResolver;\n\nclass UploadType extends AbstractType\n{\n    /**\n     * {@inheritdoc}\n     */\n    public function buildForm(FormBuilderInterface $builder, array $options)\n    {\n        $builder\n            ->add('name', TextType::class)\n            ->add('file', FileType::class)\n        ;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function configureOptions(OptionsResolver $resolver)\n    {\n        $resolver->setDefaults([\n            'data_class' => 'AppBundle\\Entity\\File',\n        ]);\n    }\n}\n```\n\nIn addition to this form, I'll link it to an **AppBundle\\Entity\\File** entity, which will then allow me to persist it in the database.\n\n```php\n<?php\n// src/AppBundle/Entity/File.php\n\nnamespace AppBundle\\Entity;\n\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\nuse Doctrine\\ORM\\Mapping as ORM;\nuse Symfony\\Component\\Validator\\Constraints as Assert;\n\n/**\n * @ORM\\Entity(repositoryClass=\"AppBundle\\Repository\\FileRepository\")\n */\nclass File\n{\n    /**\n     * @ORM\\Id()\n     * @ORM\\Column(type=\"integer\")\n     * @ORM\\GeneratedValue(strategy=\"AUTO\")\n     *\n     * @var int\n     */\n    private $id;\n\n    /**\n     * @ORM\\Column(type=\"string\")\n     * @Assert\\NotBlank(message=\"Name should not be blank.\")\n     * @Assert\\Type(\"string\")\n     *\n     * @var string\n     */\n    private $name;\n\n    /**\n     * @Assert\\NotBlank(message=\"File should not be blank.\")\n     * @Assert\\File(\n     *     mimeTypes={\"image/jpeg\", \"image/png\", \"image/gif\", \"application/x-gzip\", \"application/zip\"},\n     *     maxSize=\"1074000000\"\n     * )\n     *\n     * @var UploadedFile\n     */\n    private $file;\n\n    /**\n     * @ORM\\Column(type=\"string\")\n     *\n     * @var string\n     */\n    private $path;\n```\n\nI added constraints on the **file** field. It allows me to validate that the file that I will upload is the right type and a maximum size of 1Go.\n\nOn the controller side, I set up a route to display my form and another to handle the file upload query.\n\n\n```php\n<?php\n// src/AppBundle/Controller/DefaultController.php\nnamespace AppBundle\\Controller;\n\nuse AppBundle\\Form\\UploadType;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Route;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\nuse Symfony\\Component\\Form\\FormInterface;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass DefaultController extends Controller\n{\n    /**\n     * @Route(\"/\", name=\"homepage\", methods={\"GET\"})\n     */\n    public function indexAction()\n    {\n        return $this->render('default/index.html.twig');\n    }\n\n    /**\n     * @Route(\"/upload\", name=\"upload\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse|FormInterface\n     */\n    public function uploadAction(Request $request)\n    {\n        $form = $this->createForm(UploadType::class);\n        $form->handleRequest($request);\n\n        if ($form->isSubmitted() &amp;&amp; $form->isValid()) {\n            $this->getDoctrine()\n                ->getRepository('AppBundle:File')\n                ->store($form->getData());\n\n            return new JsonResponse([], 201);\n        }\n\n        return $form;\n    }\n}\n```\n\nI set up a listener on the **kernel.view** event to handle the case where the form is invalid (see src/AppBundle/EventListener/ViewListener.php).\n\nSo far, nothing surprising. I invite you to read the Symfony documentation for more information: [http://symfony.com/doc/current/controller/upload_file.html](http://symfony.com/doc/current/controller/upload_file.html){:rel=\"nofollow\"}.\n\nNow let's move to the client side with JavaScript implementation.\n\n### Client-side implementation with JavaScript\n\nAs a PHP developer, I think this part is the most interesting. This is where the magic of **[AJAX](https://fr.wikipedia.org/wiki/Ajax_(informatique)){:rel=\"nofollow\"}** will take place. As a reminder, AJAX  stands for **Asynchronous JavaScript XML**, and allows the browser to interact with the server asynchronously.\n\n[XMLHttpRequest](https://developer.mozilla.org/fr/docs/Web/API/XMLHttpRequest/Utiliser_XMLHttpRequest){:rel=\"nofollow\"} is a browser-accessible JavaScript object that allows you to create AJAX requests.\n\nI will first set up the HTML form.\n\n```html\n<form id=\"upload-form\">\n    <label for=\"name\">Name</label> <input id=\"name\" type=\"text\" name=\"name\"><br>\n    <label for=\"file\">File</label> <input id=\"file\" type=\"file\" name=\"file\">\n    <input type=\"submit\">\n</form>\n<p>Progress: <span id=\"progress-value\"></span>%</p>\n<p id=\"upload-complete\"></p>\n<p id=\"errors\"></p>\n```\n\nLike the Symfony form that I just created earlier, there are two fields: **name** and **file**.\n\nI added 3 DOM elements. They will allow me to display any errors and the progress of the upload.\n\nThen I will add a listener on the **submit** event of the form. This will allow me to upload to AJAX instead of the html form.\n\n```javascript\ndocument.getElementById('upload-form').addEventListener('submit', onSubmit);\n\nfunction onSubmit(event) {\n    event.preventDefault();\n\n    var formData = new FormData();\n    formData.append(\"upload[file]\", document.getElementById(\"file\").files[0]);\n    formData.append(\"upload[name]\", document.getElementById(\"name\").value);\n\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"POST\", \"/upload\");\n    xhr.addEventListener('load', onRequestComplete, false);\n    xhr.upload.addEventListener(\"load\", onUploadComplete, false);\n    xhr.upload.addEventListener(\"progress\", onUploadProgress, false);\n    xhr.send(formData);\n}\n```\n\nAt first, I will take all the form fields and put them in the **[FormData](https://developer.mozilla.org/fr/docs/Web/API/FormData){:rel=\"nofollow\"}** object. It facilitates the transport of form values. This object will then be used during the AJAX query.\n\nThen, I prepare my  **XMLHttpRequest** object. I tell him where to post the data, add some listeners and finally I pass my **FormData** object to the **send()** method to send the data.\n\nIn this way, this will create an upload request with the **multipart** header and all this asynchronously.\n\nExample of HTTP request:\n\n```sh\nPOST /upload HTTP/1.1\nHost: localhost:8000\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\nAccept: */*\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nReferer: http://localhost:8000/\nContent-Length: 74305\nContent-Type: multipart/form-data; boundary=---------------------------11413465171617698502697247091\nCookie: PHPSESSID=4vgbbv15gbfevea18tnso6fme6\nConnection: keep-alive\n\n-----------------------------11413465171617698502697247091\nContent-Disposition: form-data; name=\"upload[file]\"; filename=\"shutterstock_321267065.jpg\"\nContent-Type: image/jpeg\n\n// much data here\n-----------------------------11413465171617698502697247091\nContent-Disposition: form-data; name=\"upload[name]\"\n\nmon fichier\n-----------------------------11413465171617698502697247091--\n```\n\nOne of the listener allows me to track the advanced upload of the file: **xhr.upload.addEventListener(\"progress\", onUploadProgress, false);**\n\n```javascript\nfunction onUploadProgress(event) {\n    if (event.lengthComputable) {\n        var percentComplete = event.loaded / event.total;\n        document.getElementById('progress-value').textContent = parseFloat(percentComplete*100).toFixed(2);\n    }\n}\n```\n\nA **ProgressEvent** object passed to the **onUploadProgress** callback function. It contains information about the progress of the file upload. In my example, I display percentage progress. But we can imagine a progress bar in CSS.\n\nSmall demo in GIF  and full code here [https://github.com/lepiaf/file-upload](https://github.com/lepiaf/file-upload){:rel=\"nofollow\"}\n\n![](/imgs/posts/2017-04-20-upload-file-ajax/upload.gif)\n\n\n### To conclude\n\nWe have seen together how to implement the upload of a file asynchronously with AJAX and Symfony. This method allows you to encode and send the file as a binary data stream. Unlike a base64 file encoding, it does not inflate the file's weight on the network. The representation of the file in base64 increases the weight of the file by **~33%**. For a few kilobytes file this increase in weight is not significant, but with a file of several megabytes, this has a significant impact. In addition, the file is properly managed by the browser and the server. This makes the upload more efficient and allows the use of a file resource representation on the server-side  (**$_FILES** on the PHP side).\n\nRéférences :\n\n- [https://developer.mozilla.org/fr/docs/Web/API/XMLHttpRequest/Utiliser_XMLHttpRequest](https://developer.mozilla.org/fr/docs/Web/API/XMLHttpRequest/Utiliser_XMLHttpRequest){:rel=\"nofollow\"}\n- [https://gist.github.com/joyrexus/524c7e811e4abf9afe56](https://gist.github.com/joyrexus/524c7e811e4abf9afe56){:rel=\"nofollow\"}\n- [http://stackoverflow.com/questions/18240692/is-using-multipart-form-data-any-better-then-json-base64](http://stackoverflow.com/questions/18240692/is-using-multipart-form-data-any-better-then-json-base64){:rel=\"nofollow\"}\n- [http://stackoverflow.com/questions/4715415/base64-what-is-the-worst-possible-increase-in-space-usage/4715499](http://stackoverflow.com/questions/4715415/base64-what-is-the-worst-possible-increase-in-space-usage/4715499){:rel=\"nofollow\"}\n- [https://tools.ietf.org/html/rfc7578](https://tools.ietf.org/html/rfc7578){:rel=\"nofollow\"}\n- [http://www.bortzmeyer.org/7578.html](http://www.bortzmeyer.org/7578.html){:rel=\"nofollow\"}\n"}